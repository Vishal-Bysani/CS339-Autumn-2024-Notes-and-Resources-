The first part of the paper discusses the limitations of conventional (von Neumann) programming languages. These languages are history-sensitive, relying on transitions between complex states, making their foundations bulky. A von Neumann computer has a CPU, a store, and a tube that transfers a single word between the CPU and store, creating whatâ€™s known as the "von Neumann bottleneck."

Von Neumann languages use variables to mimic storage cells, control statements as jump instructions, and assignment statements to fetch and store data. The assignment statement is the main bottleneck, limiting us to word-at-a-time thinking. Von Neumann programs are not hierarchical, compute word-by-word through repetition, lack generality, and make housekeeping (resource management) operations difficult to consolidate.

The framework of von Neumann languages is large because every computation changes a state. Since the semantics are closely tied to states, every detail must be included in the framework. The changeable parts of von Neumann languages have limited expressive power, offering only primitive combining forms.

Von Neumann languages lack mathematical properties, making it hard to reason about programs. Proofs about programs use logic, not the programming language itself. The axioms of von Neumann languages are not useful for direct proofs. In contrast, functional programming languages have an associated algebra, allowing program transformations and solving equations with programs as unknowns. Proofs use the language of programs directly. This approach involves a functional programming style without variables, using combining forms to build programs, an algebra of functional programs, and an applicative system to describe state transitions, which only occur during major computations.